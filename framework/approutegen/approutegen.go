package approutegen

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

var dynamicSegmentNamePattern = regexp.MustCompile(`^[a-zA-Z][a-zA-Z0-9_]*$`)
var liveContainerPattern = regexp.MustCompile(
	`(?s)<[^>]*\bid\s*=\s*"([A-Za-z0-9_-]+)"[^>]*\bdata-signals\b` +
		`|<[^>]*\bdata-signals\b[^>]*\bid\s*=\s*"([A-Za-z0-9_-]+)"`,
)
var pageViewTypePattern = regexp.MustCompile(`templ\s+Page\s*\(\s*view\s+([A-Za-z0-9_.]+)\s*\)`)
var layoutSignaturePattern = regexp.MustCompile(
	`templ\s+Layout\s*\(\s*view\s+([A-Za-z0-9_.]+)\s*,\s*child\s+templ\.Component\s*\)`,
)
var notFoundSignaturePattern = regexp.MustCompile(`templ\s+Page\s*\(\s*path\s+string\s*\)`)

type templateKind string

const (
	pageTemplate     templateKind = "page"
	layoutTemplate   templateKind = "layout"
	notFoundTemplate templateKind = "not_found"
)

const (
	defaultLiveBadRequestMessage = "invalid datastar signal payload"
	generatedResolverFileName    = "generated.go"
	generatedGoHeader            = "// Code generated by framework/cmd/approutegen. DO NOT EDIT."
	generatedTemplHeader         = "// Code generated by framework/cmd/approutegen from internal/web/app. DO NOT EDIT."
)

type generationPaths struct {
	AppRoot       string
	GenRoot       string
	GenImportRoot string
	ResolverRoot  string
}

type routeSegment struct {
	StaticName string
	ParamName  string
}

func (s routeSegment) IsParam() bool {
	return s.ParamName != ""
}

func (s routeSegment) RoutePart() string {
	if s.IsParam() {
		return "[" + s.ParamName + "]"
	}
	return s.StaticName
}

func (s routeSegment) SafePart() string {
	if s.IsParam() {
		return "param_" + strings.ToLower(s.ParamName)
	}
	return safeIdentifier(s.StaticName)
}

type templateDef struct {
	Kind       templateKind
	RouteID    string
	SourcePath string
	Segments   []routeSegment
	ModuleName string
	Package    string
	OutputDir  string
	OutputFile string
}

type routeParamDef struct {
	Name      string
	FieldName string
}

type routeMeta struct {
	RouteID        string
	Segments       []routeSegment
	RouteName      string
	ParamsTypeName string
	Params         []routeParamDef
	Page           templateDef
	PageViewType   string
	HasLive        bool
	LiveStateType  string
	LiveSelectorID string
}

type routeFiles struct {
	Templates []templateDef
	Pages     []templateDef
	Layouts   map[string]templateDef
	NotFounds map[string]templateDef
}

func Run() error {
	paths, err := resolvePaths()
	if err != nil {
		return err
	}

	routes, err := discoverRouteFiles(paths.AppRoot, paths.GenRoot)
	if err != nil {
		return err
	}
	if len(routes.Pages) == 0 {
		return errors.New("no page.templ files found in internal/web/app")
	}
	if _, ok := routes.NotFounds[""]; !ok {
		return errors.New("root 404 template is required: internal/web/app/404.templ")
	}
	for _, layout := range routes.Layouts {
		if err := validateLayoutTemplateSignature(layout.SourcePath); err != nil {
			return err
		}
	}
	for _, notFound := range routes.NotFounds {
		if err := validateNotFoundTemplateSignature(notFound.SourcePath); err != nil {
			return err
		}
	}

	metas, err := buildRouteMetas(routes.Pages, paths)
	if err != nil {
		return err
	}

	if err := os.RemoveAll(paths.GenRoot); err != nil {
		return fmt.Errorf("clear generated output: %w", err)
	}
	if err := os.MkdirAll(paths.GenRoot, 0o755); err != nil {
		return fmt.Errorf("create generated output root: %w", err)
	}

	for _, tpl := range routes.Templates {
		if err := writeTemplCopy(tpl); err != nil {
			return err
		}
	}

	resolversSource, err := generateResolverNamespaceSource(metas)
	if err != nil {
		return err
	}
	if err := os.MkdirAll(paths.ResolverRoot, 0o755); err != nil {
		return fmt.Errorf("create resolver namespace root %q: %w", paths.ResolverRoot, err)
	}
	if err := os.WriteFile(filepath.Join(paths.ResolverRoot, generatedResolverFileName), resolversSource, 0o644); err != nil {
		return fmt.Errorf("write %s: %w", generatedResolverFileName, err)
	}

	registrySource, err := generateRegistrySource(paths, metas, routes.Layouts, routes.NotFounds)
	if err != nil {
		return err
	}
	if err := os.WriteFile(filepath.Join(paths.GenRoot, "registry_gen.go"), registrySource, 0o644); err != nil {
		return fmt.Errorf("write registry_gen.go: %w", err)
	}

	return nil
}

func resolvePaths() (generationPaths, error) {
	moduleRoot, err := findModuleRoot()
	if err != nil {
		return generationPaths{}, err
	}

	return generationPaths{
		AppRoot:       filepath.ToSlash(filepath.Join(moduleRoot, "internal/web/app")),
		GenRoot:       filepath.ToSlash(filepath.Join(moduleRoot, "internal/web/gen")),
		GenImportRoot: "internal/web/gen",
		ResolverRoot:  filepath.ToSlash(filepath.Join(moduleRoot, "internal/web/resolvers")),
	}, nil
}

func findModuleRoot() (string, error) {
	currentDir, err := os.Getwd()
	if err != nil {
		return "", fmt.Errorf("resolve working directory: %w", err)
	}

	for {
		if pathExists(filepath.Join(currentDir, "internal/web/app")) {
			return currentDir, nil
		}

		parentDir := filepath.Dir(currentDir)
		if parentDir == currentDir {
			break
		}
		currentDir = parentDir
	}

	return "", errors.New("strict app root missing: expected internal/web/app")
}

func pathExists(target string) bool {
	_, err := os.Stat(target)
	return err == nil
}

func discoverRouteFiles(appRoot string, outputRoot string) (routeFiles, error) {
	templates := make([]templateDef, 0, 16)
	pages := make([]templateDef, 0, 8)
	layouts := make(map[string]templateDef)
	notFounds := make(map[string]templateDef)

	walkErr := filepath.WalkDir(appRoot, func(filePath string, entry fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if entry.IsDir() {
			return nil
		}

		relPath, relErr := filepath.Rel(appRoot, filePath)
		if relErr != nil {
			return fmt.Errorf("resolve relative path for %q: %w", filePath, relErr)
		}
		relPath = filepath.ToSlash(relPath)

		if !strings.HasSuffix(relPath, ".templ") {
			return nil
		}

		if strings.HasPrefix(relPath, "components/") || strings.Contains(relPath, "/components/") {
			return fmt.Errorf("component templates must be under internal/web/components: %q", relPath)
		}

		base := path.Base(relPath)
		var kind templateKind
		switch base {
		case "page.templ":
			kind = pageTemplate
		case "layout.templ":
			kind = layoutTemplate
		case "404.templ":
			kind = notFoundTemplate
		default:
			return fmt.Errorf("unsupported route template %q; only page.templ/layout.templ/404.templ are allowed", relPath)
		}

		routeDir := path.Dir(relPath)
		if routeDir == "." {
			routeDir = ""
		}

		segments, parseErr := parseRouteSegments(routeDir)
		if parseErr != nil {
			return fmt.Errorf("parse route in %q: %w", relPath, parseErr)
		}

		routeID := routeIDFromSegments(segments)
		moduleName := moduleNameFor(kind, segments)
		tpl := templateDef{
			Kind:       kind,
			RouteID:    routeID,
			SourcePath: filepath.ToSlash(filePath),
			Segments:   segments,
			ModuleName: moduleName,
			Package:    moduleName,
			OutputDir:  filepath.ToSlash(filepath.Join(outputRoot, moduleName)),
			OutputFile: templateOutputFileName(kind),
		}
		templates = append(templates, tpl)
		if kind == pageTemplate {
			pages = append(pages, tpl)
		}
		if kind == layoutTemplate {
			layouts[routeID] = tpl
		}
		if kind == notFoundTemplate {
			notFounds[routeID] = tpl
		}

		return nil
	})
	if walkErr != nil {
		return routeFiles{}, fmt.Errorf("walk app templates: %w", walkErr)
	}

	sort.Slice(templates, func(i int, j int) bool {
		left := templates[i]
		right := templates[j]
		if left.RouteID != right.RouteID {
			return left.RouteID < right.RouteID
		}
		return left.Kind < right.Kind
	})
	sort.Slice(pages, func(i int, j int) bool {
		return pages[i].RouteID < pages[j].RouteID
	})

	return routeFiles{
		Templates: templates,
		Pages:     pages,
		Layouts:   layouts,
		NotFounds: notFounds,
	}, nil
}

func parseRouteSegments(routeDir string) ([]routeSegment, error) {
	if strings.TrimSpace(routeDir) == "" {
		return []routeSegment{}, nil
	}

	parts := strings.Split(routeDir, "/")
	segments := make([]routeSegment, 0, len(parts))
	for _, part := range parts {
		segment, err := parseRouteSegment(part)
		if err != nil {
			return nil, err
		}
		segments = append(segments, segment)
	}

	return segments, nil
}

func parseRouteSegment(part string) (routeSegment, error) {
	trimmed := strings.TrimSpace(part)
	if trimmed == "" {
		return routeSegment{}, errors.New("route segment cannot be empty")
	}

	if strings.HasPrefix(trimmed, "[") || strings.HasSuffix(trimmed, "]") {
		if !strings.HasPrefix(trimmed, "[") || !strings.HasSuffix(trimmed, "]") {
			return routeSegment{}, fmt.Errorf("invalid wildcard segment %q", part)
		}
		name := strings.TrimSpace(strings.TrimSuffix(strings.TrimPrefix(trimmed, "["), "]"))
		if !dynamicSegmentNamePattern.MatchString(name) {
			return routeSegment{}, fmt.Errorf("invalid wildcard name %q", name)
		}
		return routeSegment{ParamName: name}, nil
	}

	if strings.HasPrefix(trimmed, "_") {
		return routeSegment{}, fmt.Errorf(
			"legacy wildcard segment %q is not allowed; use [param] directories",
			part,
		)
	}

	if strings.ContainsAny(trimmed, "[]") {
		return routeSegment{}, fmt.Errorf("invalid static segment %q", part)
	}

	return routeSegment{StaticName: trimmed}, nil
}

func routeIDFromSegments(segments []routeSegment) string {
	if len(segments) == 0 {
		return ""
	}
	parts := make([]string, 0, len(segments))
	for _, segment := range segments {
		parts = append(parts, segment.RoutePart())
	}
	return strings.Join(parts, "/")
}

func moduleNameFor(kind templateKind, segments []routeSegment) string {
	parts := make([]string, 0, len(segments)+2)
	parts = append(parts, "r", string(kind))
	if len(segments) == 0 {
		parts = append(parts, "root")
	} else {
		for _, segment := range segments {
			parts = append(parts, segment.SafePart())
		}
	}
	return strings.Join(parts, "_")
}

func templateOutputFileName(kind templateKind) string {
	if kind == notFoundTemplate {
		return "404.templ"
	}
	return string(kind) + ".templ"
}

func buildRouteMetas(pages []templateDef, paths generationPaths) ([]routeMeta, error) {
	_ = paths
	metas := make([]routeMeta, 0, len(pages))

	for _, page := range pages {
		pageViewType, err := parsePageViewType(page.SourcePath)
		if err != nil {
			return nil, fmt.Errorf("route %q: %w", page.RouteID, err)
		}

		params, err := routeParamsFromSegments(page.RouteID, page.Segments)
		if err != nil {
			return nil, err
		}

		routeName := routeNameFromSegments(page.Segments)
		meta := routeMeta{
			RouteID:        page.RouteID,
			Segments:       page.Segments,
			RouteName:      routeName,
			ParamsTypeName: routeName + "Params",
			Params:         params,
			Page:           page,
			PageViewType:   pageViewType,
		}
		selectorID, hasLiveSelector, selectorErr := findLiveSelectorID(page.SourcePath)
		if selectorErr != nil {
			return nil, fmt.Errorf("route %q: %w", page.RouteID, selectorErr)
		}
		if hasLiveSelector {
			liveStateType, liveTypeErr := deriveLiveStateType(pageViewType)
			if liveTypeErr != nil {
				return nil, fmt.Errorf("route %q: %w", page.RouteID, liveTypeErr)
			}
			meta.HasLive = true
			meta.LiveStateType = liveStateType
			meta.LiveSelectorID = selectorID
		}
		if meta.HasLive {
			if meta.LiveSelectorID == "" {
				return nil, fmt.Errorf("route %q: live routes require a selector id", page.RouteID)
			}
			if meta.LiveStateType == "" {
				return nil, fmt.Errorf("route %q: live routes require a live state type", page.RouteID)
			}
		}
		if meta.HasLive && meta.LiveStateType == "" {
			return nil, fmt.Errorf("route %q: live route missing derived live state type", page.RouteID)
		}

		metas = append(metas, meta)
	}

	sort.Slice(metas, func(i int, j int) bool {
		return metas[i].RouteID < metas[j].RouteID
	})

	return metas, nil
}

func parsePageViewType(pageTemplatePath string) (string, error) {
	source, err := os.ReadFile(pageTemplatePath)
	if err != nil {
		return "", fmt.Errorf("read %q: %w", filepath.ToSlash(pageTemplatePath), err)
	}

	matches := pageViewTypePattern.FindStringSubmatch(string(source))
	if len(matches) < 2 {
		return "", fmt.Errorf("%q must declare templ Page(view <type>)", filepath.ToSlash(pageTemplatePath))
	}

	viewType := strings.TrimSpace(matches[1])
	if viewType == "" {
		return "", fmt.Errorf("%q has empty Page view type", filepath.ToSlash(pageTemplatePath))
	}
	if !strings.Contains(viewType, ".") {
		return "", fmt.Errorf("%q page view type %q must be package qualified", filepath.ToSlash(pageTemplatePath), viewType)
	}
	if !strings.HasPrefix(viewType, "appcore.") {
		return "", fmt.Errorf("%q page view type %q must be appcore-qualified", filepath.ToSlash(pageTemplatePath), viewType)
	}
	return viewType, nil
}

func validateLayoutTemplateSignature(layoutTemplatePath string) error {
	source, err := os.ReadFile(layoutTemplatePath)
	if err != nil {
		return fmt.Errorf("read %q: %w", filepath.ToSlash(layoutTemplatePath), err)
	}

	matches := layoutSignaturePattern.FindStringSubmatch(string(source))
	if len(matches) < 2 {
		return fmt.Errorf("%q must declare templ Layout(view appcore.RootLayoutView, child templ.Component)", filepath.ToSlash(layoutTemplatePath))
	}

	viewType := strings.TrimSpace(matches[1])
	if viewType != "appcore.RootLayoutView" {
		return fmt.Errorf(
			"%q layout view type %q must be appcore.RootLayoutView",
			filepath.ToSlash(layoutTemplatePath),
			viewType,
		)
	}

	return nil
}

func validateNotFoundTemplateSignature(notFoundTemplatePath string) error {
	source, err := os.ReadFile(notFoundTemplatePath)
	if err != nil {
		return fmt.Errorf("read %q: %w", filepath.ToSlash(notFoundTemplatePath), err)
	}

	if !notFoundSignaturePattern.Match(source) {
		return fmt.Errorf("%q must declare templ Page(path string)", filepath.ToSlash(notFoundTemplatePath))
	}

	return nil
}

func deriveLiveStateType(pageViewType string) (string, error) {
	pkgAlias, typeName, err := splitQualifiedType(pageViewType)
	if err != nil {
		return "", err
	}
	if !strings.HasSuffix(typeName, "PageView") {
		return "", fmt.Errorf("page view type %q must end with PageView to derive live state", pageViewType)
	}
	baseName := strings.TrimSuffix(typeName, "PageView")
	if strings.TrimSpace(baseName) == "" {
		return "", fmt.Errorf("page view type %q cannot derive live state", pageViewType)
	}
	return pkgAlias + "." + baseName + "SignalState", nil
}

func splitQualifiedType(typeRef string) (string, string, error) {
	parts := strings.Split(typeRef, ".")
	if len(parts) != 2 {
		return "", "", fmt.Errorf("type %q must be in package.Type form", typeRef)
	}
	pkgAlias := strings.TrimSpace(parts[0])
	typeName := strings.TrimSpace(parts[1])
	if pkgAlias == "" || typeName == "" {
		return "", "", fmt.Errorf("type %q must be in package.Type form", typeRef)
	}
	return pkgAlias, typeName, nil
}

func findLiveSelectorID(pageTemplatePath string) (string, bool, error) {
	source, err := os.ReadFile(pageTemplatePath)
	if err != nil {
		return "", false, fmt.Errorf("read %q: %w", filepath.ToSlash(pageTemplatePath), err)
	}

	text := string(source)
	matches := liveContainerPattern.FindStringSubmatch(text)
	if len(matches) == 0 {
		return "", false, nil
	}
	if matches[1] != "" {
		return matches[1], true, nil
	}
	if matches[2] != "" {
		return matches[2], true, nil
	}

	return "", false, fmt.Errorf("%q has data-signals but selector id could not be parsed", filepath.ToSlash(pageTemplatePath))
}

func routeNameFromSegments(segments []routeSegment) string {
	if len(segments) == 0 {
		return "Root"
	}

	builder := strings.Builder{}
	for _, segment := range segments {
		if segment.IsParam() {
			builder.WriteString("Param")
			builder.WriteString(pascalToken(segment.ParamName))
			continue
		}
		builder.WriteString(pascalToken(segment.StaticName))
	}

	name := builder.String()
	if name == "" {
		return "Root"
	}
	return name
}

func routeParamsFromSegments(routeID string, segments []routeSegment) ([]routeParamDef, error) {
	params := make([]routeParamDef, 0, len(segments))
	seen := make(map[string]struct{})

	for _, segment := range segments {
		if !segment.IsParam() {
			continue
		}

		fieldName := pascalToken(segment.ParamName)
		if fieldName == "" {
			return nil, fmt.Errorf("route %q has invalid param name %q", routeID, segment.ParamName)
		}
		if _, ok := seen[fieldName]; ok {
			return nil, fmt.Errorf("route %q has duplicate param field %q", routeID, fieldName)
		}
		seen[fieldName] = struct{}{}

		params = append(params, routeParamDef{
			Name:      segment.ParamName,
			FieldName: fieldName,
		})
	}

	return params, nil
}

func writeTemplCopy(tpl templateDef) error {
	source, err := os.ReadFile(tpl.SourcePath)
	if err != nil {
		return fmt.Errorf("read %q: %w", tpl.SourcePath, err)
	}

	rewritten, err := rewritePackageDeclaration(source, tpl.Package)
	if err != nil {
		return fmt.Errorf("rewrite package for %q: %w", tpl.SourcePath, err)
	}

	if err := os.MkdirAll(tpl.OutputDir, 0o755); err != nil {
		return fmt.Errorf("create output dir %q: %w", tpl.OutputDir, err)
	}

	target := filepath.Join(tpl.OutputDir, tpl.OutputFile)
	if err := os.WriteFile(target, rewritten, 0o644); err != nil {
		return fmt.Errorf("write generated template %q: %w", target, err)
	}

	return nil
}

func rewritePackageDeclaration(source []byte, packageName string) ([]byte, error) {
	lines := strings.Split(string(source), "\n")
	for i, line := range lines {
		trimmed := strings.TrimSpace(line)
		if !strings.HasPrefix(trimmed, "package ") {
			continue
		}

		lines[i] = "package " + packageName

		firstNonEmpty := i + 1
		for firstNonEmpty < len(lines) && strings.TrimSpace(lines[firstNonEmpty]) == "" {
			firstNonEmpty++
		}
		if firstNonEmpty < len(lines) && strings.TrimSpace(lines[firstNonEmpty]) == generatedTemplHeader {
			return []byte(strings.Join(lines, "\n")), nil
		}

		rewritten := make([]string, 0, len(lines)+1)
		rewritten = append(rewritten, lines[:i+1]...)
		rewritten = append(rewritten, generatedTemplHeader)
		rewritten = append(rewritten, lines[i+1:]...)
		return []byte(strings.Join(rewritten, "\n")), nil
	}

	return nil, errors.New("template missing package declaration")
}

func writeParamsStruct(buffer *bytes.Buffer, meta routeMeta) {
	writef(buffer, "type %s struct {\n", meta.ParamsTypeName)
	if len(meta.Params) == 0 {
		buffer.WriteString("}\n\n")
		return
	}
	for _, param := range meta.Params {
		writef(buffer, "\t%s string\n", param.FieldName)
	}
	buffer.WriteString("}\n\n")
}

func generateResolverNamespaceSource(metas []routeMeta) ([]byte, error) {
	buffer := &bytes.Buffer{}
	buffer.WriteString(generatedGoHeader + "\n")
	buffer.WriteString("package resolvers\n\n")
	buffer.WriteString("import (\n")
	buffer.WriteString("\t\"context\"\n")
	buffer.WriteString("\t\"net/http\"\n")
	buffer.WriteString("\t\"blog/internal/web/appcore\"\n")
	buffer.WriteString(")\n\n")

	for _, meta := range metas {
		writeParamsStruct(buffer, meta)
	}

	buffer.WriteString("type RouteResolver interface {\n")
	for _, meta := range metas {
		writef(
			buffer,
			"\t%s(ctx context.Context, appCtx *appcore.Context, r *http.Request, params %s) (%s, error)\n",
			resolvePageMethod(meta),
			meta.ParamsTypeName,
			meta.PageViewType,
		)
		if meta.HasLive {
			writef(
				buffer,
				"\t%s(r *http.Request) (%s, error)\n",
				parseLiveMethod(meta),
				meta.LiveStateType,
			)
			writef(
				buffer,
				"\t%s(ctx context.Context, appCtx *appcore.Context, r *http.Request, params %s, state %s) (%s, error)\n",
				resolveLiveMethod(meta),
				meta.ParamsTypeName,
				meta.LiveStateType,
				meta.PageViewType,
			)
		}
	}
	buffer.WriteString("}\n\n")
	buffer.WriteString("type Resolver struct{}\n\n")
	buffer.WriteString("var _ RouteResolver = (*Resolver)(nil)\n")

	formatted, err := format.Source(buffer.Bytes())
	if err != nil {
		return nil, fmt.Errorf("format resolver namespace source: %w", err)
	}
	return formatted, nil
}

func generateRegistrySource(
	paths generationPaths,
	metas []routeMeta,
	layouts map[string]templateDef,
	notFounds map[string]templateDef,
) ([]byte, error) {
	if _, ok := notFounds[""]; !ok {
		return nil, errors.New("missing root 404 template metadata")
	}

	importLines := []string{
		"\"context\"",
		"\"net/http\"",
		"\"strings\"",
		"\"blog/framework\"",
		"\"blog/framework/router\"",
		"\"blog/internal/web/appcore\"",
		"route_resolvers \"blog/internal/web/resolvers\"",
		"\"github.com/a-h/templ\"",
	}

	moduleImports := make([]string, 0, len(metas)+len(layouts)+len(notFounds))
	for _, meta := range metas {
		moduleImports = append(moduleImports, fmt.Sprintf(
			"%s \"blog/%s/%s\"",
			meta.Page.ModuleName,
			paths.GenImportRoot,
			meta.Page.ModuleName,
		))
	}

	layoutKeys := make([]string, 0, len(layouts))
	for routeID := range layouts {
		layoutKeys = append(layoutKeys, routeID)
	}
	sort.Strings(layoutKeys)
	for _, routeID := range layoutKeys {
		layout := layouts[routeID]
		moduleImports = append(moduleImports, fmt.Sprintf(
			"%s \"blog/%s/%s\"",
			layout.ModuleName,
			paths.GenImportRoot,
			layout.ModuleName,
		))
	}

	notFoundKeys := make([]string, 0, len(notFounds))
	for routeID := range notFounds {
		notFoundKeys = append(notFoundKeys, routeID)
	}
	sort.Strings(notFoundKeys)
	for _, routeID := range notFoundKeys {
		notFound := notFounds[routeID]
		moduleImports = append(moduleImports, fmt.Sprintf(
			"%s \"blog/%s/%s\"",
			notFound.ModuleName,
			paths.GenImportRoot,
			notFound.ModuleName,
		))
	}

	moduleImports = dedupeSorted(moduleImports)
	importLines = append(importLines, moduleImports...)

	buffer := &bytes.Buffer{}
	buffer.WriteString(generatedGoHeader + "\n")
	buffer.WriteString("package gen\n\n")
	buffer.WriteString("import (\n")
	for _, line := range importLines {
		buffer.WriteString("\t" + line + "\n")
	}
	buffer.WriteString(")\n\n")

	buffer.WriteString("type RouteResolvers = route_resolvers.RouteResolver\n\n")
	for _, meta := range metas {
		writef(buffer, "type %s = route_resolvers.%s\n", meta.ParamsTypeName, meta.ParamsTypeName)
	}
	if len(metas) > 0 {
		buffer.WriteString("\n")
	}
	buffer.WriteString("func NewRouteResolvers() RouteResolvers {\n")
	buffer.WriteString("\treturn &route_resolvers.Resolver{}\n")
	buffer.WriteString("}\n\n")

	buffer.WriteString("func Handlers(resolvers RouteResolvers) []framework.RouteHandler[*appcore.Context] {\n")
	buffer.WriteString("\treturn []framework.RouteHandler[*appcore.Context]{\n")
	for _, meta := range metas {
		if meta.HasLive {
			writef(
				buffer,
				"\t\tframework.PageAndLiveRouteHandler[*appcore.Context, %s, %s, %s]{\n",
				meta.ParamsTypeName,
				meta.PageViewType,
				meta.LiveStateType,
			)
		} else {
			writef(
				buffer,
				"\t\tframework.PageOnlyRouteHandler[*appcore.Context, %s, %s]{\n",
				meta.ParamsTypeName,
				meta.PageViewType,
			)
		}

		writePageModule(buffer, meta, layouts)
		if meta.HasLive {
			writeLiveModule(buffer, meta)
		}
		buffer.WriteString("\t\t},\n")
	}
	buffer.WriteString("\t}\n")
	buffer.WriteString("}\n\n")

	writeNotFoundPageFunc(buffer, layouts, notFounds)

	for _, meta := range metas {
		writeParseParamsFunc(buffer, meta, false)
		if meta.HasLive {
			writeParseParamsFunc(buffer, meta, true)
		}
	}

	wrappers, err := collectLayoutWrappers(metas, layouts)
	if err != nil {
		return nil, err
	}
	wrapperNames := make([]string, 0, len(wrappers))
	for name := range wrappers {
		wrapperNames = append(wrapperNames, name)
	}
	sort.Strings(wrapperNames)
	for _, name := range wrapperNames {
		wrapper := wrappers[name]
		writef(
			buffer,
			"func %s(view %s, child templ.Component) templ.Component {\n",
			wrapper.Name,
			wrapper.ViewType,
		)
		writef(buffer, "\treturn %s.Layout(view, child)\n", wrapper.LayoutModule)
		buffer.WriteString("}\n\n")
	}

	formatted, err := format.Source(buffer.Bytes())
	if err != nil {
		return nil, fmt.Errorf("format registry source: %w", err)
	}
	return formatted, nil
}

func writeNotFoundPageFunc(
	buffer *bytes.Buffer,
	layouts map[string]templateDef,
	notFounds map[string]templateDef,
) {
	notFoundKeys := make([]string, 0, len(notFounds))
	dynamicNotFoundKeys := make([]string, 0, len(notFounds))
	for routeID := range notFounds {
		notFoundKeys = append(notFoundKeys, routeID)
		if strings.Contains(routeID, "[") {
			dynamicNotFoundKeys = append(dynamicNotFoundKeys, routeID)
		}
	}
	sort.Strings(notFoundKeys)
	sort.Slice(dynamicNotFoundKeys, func(i int, j int) bool {
		left := routeIDSegmentCount(dynamicNotFoundKeys[i])
		right := routeIDSegmentCount(dynamicNotFoundKeys[j])
		if left != right {
			return left > right
		}
		return dynamicNotFoundKeys[i] < dynamicNotFoundKeys[j]
	})

	buffer.WriteString("func NotFoundPage(notFound framework.NotFoundContext) templ.Component {\n")
	buffer.WriteString("\tpathValue := strings.TrimSpace(notFound.RequestPath)\n")
	buffer.WriteString("\tif pathValue == \"\" {\n")
	buffer.WriteString("\t\tpathValue = \"/\"\n")
	buffer.WriteString("\t}\n")
	buffer.WriteString("\trouteID := nearestNotFoundRouteID(notFound)\n")
	buffer.WriteString("\tview := appcore.NewNotFoundLayoutView()\n")
	buffer.WriteString("\tswitch routeID {\n")
	for _, routeID := range notFoundKeys {
		if routeID == "" {
			continue
		}
		notFound := notFounds[routeID]
		writef(buffer, "\tcase %q:\n", routeID)
		writef(buffer, "\t\tcomponent := %s.Page(pathValue)\n", notFound.ModuleName)
		chain := layoutChain(routeID, layouts)
		for idx := len(chain) - 1; idx >= 0; idx-- {
			writef(buffer, "\t\tcomponent = %s.Layout(view, component)\n", chain[idx].ModuleName)
		}
		buffer.WriteString("\t\treturn component\n")
	}

	rootNotFound := notFounds[""]
	buffer.WriteString("\tdefault:\n")
	writef(buffer, "\t\tcomponent := %s.Page(pathValue)\n", rootNotFound.ModuleName)
	rootChain := layoutChain("", layouts)
	for idx := len(rootChain) - 1; idx >= 0; idx-- {
		writef(buffer, "\t\tcomponent = %s.Layout(view, component)\n", rootChain[idx].ModuleName)
	}
	buffer.WriteString("\t\treturn component\n")
	buffer.WriteString("\t}\n")
	buffer.WriteString("}\n\n")

	buffer.WriteString("func nearestNotFoundRouteID(notFound framework.NotFoundContext) string {\n")
	buffer.WriteString("\tfor _, candidate := range candidateRouteIDsFromPattern(notFound.MatchedRoutePattern) {\n")
	buffer.WriteString("\t\tif routeID, ok := resolveNotFoundCandidateRouteID(candidate); ok {\n")
	buffer.WriteString("\t\t\treturn routeID\n")
	buffer.WriteString("\t\t}\n")
	buffer.WriteString("\t}\n")
	buffer.WriteString("\tfor _, candidate := range candidateRouteIDsFromPath(notFound.RequestPath) {\n")
	buffer.WriteString("\t\tif routeID, ok := resolveNotFoundCandidateRouteID(candidate); ok {\n")
	buffer.WriteString("\t\t\treturn routeID\n")
	buffer.WriteString("\t\t}\n")
	buffer.WriteString("\t}\n")
	buffer.WriteString("\treturn \"\"\n")
	buffer.WriteString("}\n\n")

	buffer.WriteString("func resolveNotFoundCandidateRouteID(candidate string) (string, bool) {\n")
	buffer.WriteString("\tif hasNotFoundTemplate(candidate) {\n")
	buffer.WriteString("\t\treturn candidate, true\n")
	buffer.WriteString("\t}\n")
	buffer.WriteString("\tif candidate == \"\" {\n")
	buffer.WriteString("\t\treturn \"\", false\n")
	buffer.WriteString("\t}\n")
	buffer.WriteString("\trouteID, ok := matchDynamicNotFoundTemplate(candidate)\n")
	buffer.WriteString("\tif !ok {\n")
	buffer.WriteString("\t\treturn \"\", false\n")
	buffer.WriteString("\t}\n")
	buffer.WriteString("\treturn routeID, true\n")
	buffer.WriteString("}\n\n")

	buffer.WriteString("func matchDynamicNotFoundTemplate(candidate string) (string, bool) {\n")
	buffer.WriteString("\tif candidate == \"\" {\n")
	buffer.WriteString("\t\treturn \"\", false\n")
	buffer.WriteString("\t}\n")
	if len(dynamicNotFoundKeys) > 0 {
		buffer.WriteString("\trequestPath := \"/\" + candidate\n")
	}
	for _, routeID := range dynamicNotFoundKeys {
		writef(buffer, "\tif _, ok := router.MatchPathPattern(%q, requestPath); ok {\n", routePattern(routeID))
		writef(buffer, "\t\treturn %q, true\n", routeID)
		buffer.WriteString("\t}\n")
	}
	buffer.WriteString("\treturn \"\", false\n")
	buffer.WriteString("}\n\n")

	buffer.WriteString("func hasNotFoundTemplate(routeID string) bool {\n")
	buffer.WriteString("\tswitch routeID {\n")
	for _, routeID := range notFoundKeys {
		writef(buffer, "\tcase %q:\n", routeID)
	}
	buffer.WriteString("\t\treturn true\n")
	buffer.WriteString("\tdefault:\n")
	buffer.WriteString("\t\treturn false\n")
	buffer.WriteString("\t}\n")
	buffer.WriteString("}\n\n")

	buffer.WriteString("func candidateRouteIDsFromPattern(pattern string) []string {\n")
	buffer.WriteString("\trouteID := normalizePatternRouteID(pattern)\n")
	buffer.WriteString("\treturn routeAncestry(routeID)\n")
	buffer.WriteString("}\n\n")

	buffer.WriteString("func candidateRouteIDsFromPath(requestPath string) []string {\n")
	buffer.WriteString("\trouteID := normalizeRequestRouteID(requestPath)\n")
	buffer.WriteString("\treturn routeAncestry(routeID)\n")
	buffer.WriteString("}\n\n")

	buffer.WriteString("func normalizePatternRouteID(pattern string) string {\n")
	buffer.WriteString("\trouteID := strings.TrimSpace(pattern)\n")
	buffer.WriteString("\trouteID = strings.Trim(routeID, \"/\")\n")
	buffer.WriteString("\tif routeID == \".live\" {\n")
	buffer.WriteString("\t\treturn \"\"\n")
	buffer.WriteString("\t}\n")
	buffer.WriteString("\tif strings.HasPrefix(routeID, \".live/\") {\n")
	buffer.WriteString("\t\trouteID = strings.TrimPrefix(routeID, \".live/\")\n")
	buffer.WriteString("\t\trouteID = strings.Trim(routeID, \"/\")\n")
	buffer.WriteString("\t}\n")
	buffer.WriteString("\treturn routeID\n")
	buffer.WriteString("}\n\n")

	buffer.WriteString("func normalizeRequestRouteID(requestPath string) string {\n")
	buffer.WriteString("\trouteID := strings.TrimSpace(requestPath)\n")
	buffer.WriteString("\trouteID = strings.Trim(routeID, \"/\")\n")
	buffer.WriteString("\tif routeID == \".live\" {\n")
	buffer.WriteString("\t\treturn \"\"\n")
	buffer.WriteString("\t}\n")
	buffer.WriteString("\tif strings.HasPrefix(routeID, \".live/\") {\n")
	buffer.WriteString("\t\trouteID = strings.TrimPrefix(routeID, \".live/\")\n")
	buffer.WriteString("\t\trouteID = strings.Trim(routeID, \"/\")\n")
	buffer.WriteString("\t}\n")
	buffer.WriteString("\treturn routeID\n")
	buffer.WriteString("}\n\n")

	buffer.WriteString("func routeAncestry(routeID string) []string {\n")
	buffer.WriteString("\trouteID = strings.TrimSpace(routeID)\n")
	buffer.WriteString("\trouteID = strings.Trim(routeID, \"/\")\n")
	buffer.WriteString("\tif routeID == \"\" {\n")
	buffer.WriteString("\t\treturn []string{\"\"}\n")
	buffer.WriteString("\t}\n")
	buffer.WriteString("\tparts := strings.Split(routeID, \"/\")\n")
	buffer.WriteString("\tout := make([]string, 0, len(parts)+1)\n")
	buffer.WriteString("\tfor idx := len(parts); idx >= 1; idx-- {\n")
	buffer.WriteString("\t\tout = append(out, strings.Join(parts[:idx], \"/\"))\n")
	buffer.WriteString("\t}\n")
	buffer.WriteString("\tout = append(out, \"\")\n")
	buffer.WriteString("\treturn out\n")
	buffer.WriteString("}\n\n")
}

func routeIDSegmentCount(routeID string) int {
	routeID = strings.TrimSpace(routeID)
	routeID = strings.Trim(routeID, "/")
	if routeID == "" {
		return 0
	}
	return len(strings.Split(routeID, "/"))
}

type layoutWrapperDef struct {
	Name         string
	ViewType     string
	LayoutModule string
}

func writePageModule(buffer *bytes.Buffer, meta routeMeta, layouts map[string]templateDef) {
	writef(
		buffer,
		"\t\t\tPage: framework.PageModule[*appcore.Context, %s, %s]{\n",
		meta.ParamsTypeName,
		meta.PageViewType,
	)
	writef(buffer, "\t\t\t\tPattern:     %q,\n", routePattern(meta.RouteID))
	writef(buffer, "\t\t\t\tParseParams: %s,\n", parseParamsFuncName(meta, false))
	writef(
		buffer,
		"\t\t\t\tLoad: func(ctx context.Context, appCtx *appcore.Context, r *http.Request, "+
			"params %s) (%s, error) {\n",
		meta.ParamsTypeName,
		meta.PageViewType,
	)
	writef(buffer, "\t\t\t\t\treturn resolvers.%s(ctx, appCtx, r, params)\n", resolvePageMethod(meta))
	buffer.WriteString("\t\t\t\t},\n")
	writef(buffer, "\t\t\t\tRender: %s.Page,\n", meta.Page.ModuleName)

	chain := layoutChain(meta.RouteID, layouts)
	if len(chain) == 0 {
		writef(buffer, "\t\t\t\tLayouts: []framework.LayoutRenderer[%s]{},\n", meta.PageViewType)
	} else {
		writef(buffer, "\t\t\t\tLayouts: []framework.LayoutRenderer[%s]{\n", meta.PageViewType)
		for _, layout := range chain {
			layoutName := routeNameFromSegments(layout.Segments)
			writef(buffer, "\t\t\t\t\t%s,\n", wrapperFuncName(meta.RouteName, layoutName))
		}
		buffer.WriteString("\t\t\t\t},\n")
	}
	buffer.WriteString("\t\t\t},\n")
}

func writeLiveModule(buffer *bytes.Buffer, meta routeMeta) {
	writef(
		buffer,
		"\t\t\tLive: framework.LiveModule[*appcore.Context, %s, %s, %s]{\n",
		meta.ParamsTypeName,
		meta.PageViewType,
		meta.LiveStateType,
	)
	writef(buffer, "\t\t\t\tPattern:           %q,\n", liveRoutePattern(meta.RouteID))
	writef(buffer, "\t\t\t\tParseParams:       %s,\n", parseParamsFuncName(meta, true))
	writef(buffer, "\t\t\t\tParseState:        resolvers.%s,\n", parseLiveMethod(meta))
	writef(
		buffer,
		"\t\t\t\tLoad: func(ctx context.Context, appCtx *appcore.Context, r *http.Request, "+
			"params %s, state %s) (%s, error) {\n",
		meta.ParamsTypeName,
		meta.LiveStateType,
		meta.PageViewType,
	)
	writef(buffer, "\t\t\t\t\treturn resolvers.%s(ctx, appCtx, r, params, state)\n", resolveLiveMethod(meta))
	buffer.WriteString("\t\t\t\t},\n")
	writef(buffer, "\t\t\t\tRender:            %s.Page,\n", meta.Page.ModuleName)
	writef(buffer, "\t\t\t\tSelectorID:        %q,\n", meta.LiveSelectorID)
	writef(buffer, "\t\t\t\tBadRequestMessage: %q,\n", defaultLiveBadRequestMessage)
	buffer.WriteString("\t\t\t},\n")
}

func collectLayoutWrappers(metas []routeMeta, layouts map[string]templateDef) (map[string]layoutWrapperDef, error) {
	wrappers := make(map[string]layoutWrapperDef)
	for _, meta := range metas {
		chain := layoutChain(meta.RouteID, layouts)
		for _, layout := range chain {
			layoutName := routeNameFromSegments(layout.Segments)
			name := wrapperFuncName(meta.RouteName, layoutName)
			def := layoutWrapperDef{
				Name:         name,
				ViewType:     meta.PageViewType,
				LayoutModule: layout.ModuleName,
			}

			existing, ok := wrappers[name]
			if !ok {
				wrappers[name] = def
				continue
			}
			if existing.ViewType != def.ViewType || existing.LayoutModule != def.LayoutModule {
				return nil, fmt.Errorf("layout wrapper conflict for %q", name)
			}
		}
	}

	return wrappers, nil
}

func parseParamsFuncName(meta routeMeta, live bool) string {
	if live {
		return "parse" + meta.RouteName + "LiveParams"
	}
	return "parse" + meta.RouteName + "Params"
}

func writeParseParamsFunc(buffer *bytes.Buffer, meta routeMeta, live bool) {
	funcName := parseParamsFuncName(meta, live)
	pattern := routePattern(meta.RouteID)
	if live {
		pattern = liveRoutePattern(meta.RouteID)
	}

	writef(buffer, "func %s(requestPath string) (%s, bool) {\n", funcName, meta.ParamsTypeName)
	if len(meta.Params) == 0 {
		writef(buffer, "\t_, ok := router.MatchPathPattern(%q, requestPath)\n", pattern)
		buffer.WriteString("\tif !ok {\n")
		writef(buffer, "\t\treturn %s{}, false\n", meta.ParamsTypeName)
		buffer.WriteString("\t}\n")
		writef(buffer, "\treturn %s{}, true\n", meta.ParamsTypeName)
		buffer.WriteString("}\n\n")
		return
	}

	writef(buffer, "\tparams, ok := router.MatchPathPattern(%q, requestPath)\n", pattern)
	buffer.WriteString("\tif !ok {\n")
	writef(buffer, "\t\treturn %s{}, false\n", meta.ParamsTypeName)
	buffer.WriteString("\t}\n")
	writef(buffer, "\tout := %s{}\n", meta.ParamsTypeName)
	for _, param := range meta.Params {
		writef(buffer, "\t%sValue := strings.TrimSpace(params[%q])\n", param.FieldName, param.Name)
		if param.Name == "slug" {
			writef(buffer, "\tif !router.IsValidSlug(%sValue) {\n", param.FieldName)
			writef(buffer, "\t\treturn %s{}, false\n", meta.ParamsTypeName)
			buffer.WriteString("\t}\n")
		}
		writef(buffer, "\tout.%s = %sValue\n", param.FieldName, param.FieldName)
	}
	buffer.WriteString("\treturn out, true\n")
	buffer.WriteString("}\n\n")
}

func routePattern(routeID string) string {
	if routeID == "" {
		return "/"
	}
	return "/" + routeID
}

func liveRoutePattern(routeID string) string {
	if routeID == "" {
		return "/.live/"
	}
	return "/.live/" + routeID
}

func resolvePageMethod(meta routeMeta) string {
	return "Resolve" + meta.RouteName + "Page"
}

func parseLiveMethod(meta routeMeta) string {
	return "Parse" + meta.RouteName + "LiveState"
}

func resolveLiveMethod(meta routeMeta) string {
	return "Resolve" + meta.RouteName + "Live"
}

func wrapperFuncName(routeName string, layoutName string) string {
	return "wrap" + routeName + "With" + layoutName + "Layout"
}

func layoutChain(routeID string, layouts map[string]templateDef) []templateDef {
	segments := []string{}
	if routeID != "" {
		segments = strings.Split(routeID, "/")
	}

	candidates := make([]string, 0, len(segments)+1)
	candidates = append(candidates, "")
	for idx := 1; idx <= len(segments); idx++ {
		candidates = append(candidates, strings.Join(segments[:idx], "/"))
	}

	chain := make([]templateDef, 0, len(candidates))
	for _, candidate := range candidates {
		layout, ok := layouts[candidate]
		if !ok {
			continue
		}
		chain = append(chain, layout)
	}

	return chain
}

func safeIdentifier(value string) string {
	trimmed := strings.TrimSpace(value)
	if trimmed == "" {
		return "value"
	}

	normalized := strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') {
			return r
		}
		return '_'
	}, trimmed)
	normalized = strings.Trim(normalized, "_")
	if normalized == "" {
		return "value"
	}
	return strings.ToLower(normalized)
}

func pascalToken(value string) string {
	normalized := strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') {
			return r
		}
		return ' '
	}, strings.TrimSpace(value))

	parts := strings.Fields(normalized)
	if len(parts) == 0 {
		return ""
	}

	builder := strings.Builder{}
	for _, part := range parts {
		if part == "" {
			continue
		}
		builder.WriteString(strings.ToUpper(part[:1]))
		if len(part) > 1 {
			builder.WriteString(strings.ToLower(part[1:]))
		}
	}

	return builder.String()
}

func writef(buffer *bytes.Buffer, pattern string, args ...interface{}) {
	_, _ = fmt.Fprintf(buffer, pattern, args...)
}

func dedupeSorted(values []string) []string {
	sort.Strings(values)
	if len(values) == 0 {
		return values
	}

	out := make([]string, 0, len(values))
	previous := ""
	for idx, value := range values {
		if idx > 0 && value == previous {
			continue
		}
		out = append(out, value)
		previous = value
	}

	return out
}
