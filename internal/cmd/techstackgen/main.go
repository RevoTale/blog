package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

type packageEntry struct {
	Name string
	URL  string
}

var majorVersionSegment = regexp.MustCompile(`^v[0-9]+$`)

func main() {
	var inPath string
	var outPath string

	flag.StringVar(&inPath, "in", "go.mod", "path to go.mod")
	flag.StringVar(&outPath, "out", "internal/techstack/generated.go", "output generated Go file")
	flag.Parse()

	modules, err := parseDirectModules(inPath)
	if err != nil {
		exitf("parse %s: %v", inPath, err)
	}

	content, err := renderGoSource(buildPackageList(modules))
	if err != nil {
		exitf("render generated source: %v", err)
	}

	if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
		exitf("create output directory: %v", err)
	}
	if err := os.WriteFile(outPath, content, 0o644); err != nil {
		exitf("write %s: %v", outPath, err)
	}
}

func parseDirectModules(path string) ([]string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	lines := strings.Split(string(data), "\n")
	modules := make([]string, 0, 8)
	seen := make(map[string]struct{})
	inRequireBlock := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if trimmed == "" || strings.HasPrefix(trimmed, "//") {
			continue
		}

		switch {
		case strings.HasPrefix(trimmed, "require ("):
			inRequireBlock = true
			continue
		case inRequireBlock && trimmed == ")":
			inRequireBlock = false
			continue
		}

		if inRequireBlock {
			module, indirect := parseRequireEntry(trimmed)
			appendModule(module, indirect, seen, &modules)
			continue
		}

		if strings.HasPrefix(trimmed, "require ") {
			entry := strings.TrimSpace(strings.TrimPrefix(trimmed, "require "))
			module, indirect := parseRequireEntry(entry)
			appendModule(module, indirect, seen, &modules)
		}
	}

	return modules, nil
}

func parseRequireEntry(entry string) (module string, indirect bool) {
	raw := entry
	comment := ""
	if index := strings.Index(raw, "//"); index >= 0 {
		comment = strings.TrimSpace(raw[index+2:])
		raw = strings.TrimSpace(raw[:index])
	}

	fields := strings.Fields(raw)
	if len(fields) < 2 {
		return "", false
	}

	if strings.Contains(comment, "indirect") {
		indirect = true
	}

	return fields[0], indirect
}

func appendModule(module string, indirect bool, seen map[string]struct{}, modules *[]string) {
	if module == "" || indirect {
		return
	}
	if _, ok := seen[module]; ok {
		return
	}
	seen[module] = struct{}{}
	*modules = append(*modules, module)
}

func buildPackageList(modules []string) []packageEntry {
	items := make([]packageEntry, 0, len(modules))
	for _, module := range modules {
		items = append(items, packageEntry{
			Name: packageName(module),
			URL:  repositoryURL(module),
		})
	}

	return items
}

func packageName(module string) string {
	trimmed := strings.Trim(module, "/")
	if trimmed == "" {
		return module
	}

	parts := strings.Split(trimmed, "/")
	name := parts[len(parts)-1]
	if majorVersionSegment.MatchString(name) && len(parts) > 1 {
		return parts[len(parts)-2]
	}

	return name
}

func repositoryURL(module string) string {
	parts := strings.Split(strings.Trim(module, "/"), "/")
	if len(parts) >= 3 {
		host := parts[0]
		switch host {
		case "github.com", "gitlab.com", "bitbucket.org":
			return "https://" + strings.Join(parts[:3], "/")
		}
	}

	return "https://pkg.go.dev/" + module
}

func renderGoSource(packages []packageEntry) ([]byte, error) {
	var out bytes.Buffer

	out.WriteString("// Code generated by internal/cmd/techstackgen; DO NOT EDIT.\n\n")
	out.WriteString("package techstack\n\n")
	out.WriteString("type Package struct {\n")
	out.WriteString("\tName string\n")
	out.WriteString("\tURL  string\n")
	out.WriteString("}\n\n")
	out.WriteString("var packages = []Package{\n")
	for _, pkg := range packages {
		fmt.Fprintf(&out, "\t{Name: %q, URL: %q},\n", pkg.Name, pkg.URL)
	}
	out.WriteString("}\n\n")
	out.WriteString("func Packages() []Package {\n")
	out.WriteString("\tcopied := make([]Package, len(packages))\n")
	out.WriteString("\tcopy(copied, packages)\n")
	out.WriteString("\treturn copied\n")
	out.WriteString("}\n")

	formatted, err := format.Source(out.Bytes())
	if err != nil {
		return nil, err
	}

	return formatted, nil
}

func exitf(formatText string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, formatText+"\n", args...)
	os.Exit(1)
}
