package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/mod/modfile"
)

type packageEntry struct {
	Name string
	URL  string
}

func main() {
	var inPath string
	var outPath string

	flag.StringVar(&inPath, "in", "go.mod", "path to go.mod")
	flag.StringVar(&outPath, "out", "internal/techstack/generated.go", "output generated Go file")
	flag.Parse()

	modules, err := parseDirectModules(inPath)
	if err != nil {
		exitf("parse %s: %v", inPath, err)
	}

	content, err := renderGoSource(buildPackageList(modules))
	if err != nil {
		exitf("render generated source: %v", err)
	}

	if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
		exitf("create output directory: %v", err)
	}
	if err := os.WriteFile(outPath, content, 0o644); err != nil {
		exitf("write %s: %v", outPath, err)
	}
}

func parseDirectModules(path string) ([]string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	file, err := modfile.Parse(path, data, nil)
	if err != nil {
		return nil, err
	}

	modules := make([]string, 0, len(file.Require))
	seen := make(map[string]struct{}, len(file.Require))
	for _, req := range file.Require {
		if req == nil || req.Indirect {
			continue
		}

		module := strings.TrimSpace(req.Mod.Path)
		if module == "" {
			continue
		}
		if _, ok := seen[module]; ok {
			continue
		}

		seen[module] = struct{}{}
		modules = append(modules, module)
	}

	return modules, nil
}

func buildPackageList(modules []string) []packageEntry {
	items := make([]packageEntry, 0, len(modules))
	for _, module := range modules {
		items = append(items, packageEntry{
			Name: module,
			URL:  "https://pkg.go.dev/" + module,
		})
	}

	return items
}

func renderGoSource(packages []packageEntry) ([]byte, error) {
	var out bytes.Buffer

	out.WriteString("// Code generated by internal/cmd/techstackgen; DO NOT EDIT.\n\n")
	out.WriteString("package techstack\n\n")
	out.WriteString("type Package struct {\n")
	out.WriteString("\tName string\n")
	out.WriteString("\tURL  string\n")
	out.WriteString("}\n\n")
	out.WriteString("var packages = []Package{\n")
	for _, pkg := range packages {
		fmt.Fprintf(&out, "\t{Name: %q, URL: %q},\n", pkg.Name, pkg.URL)
	}
	out.WriteString("}\n\n")
	out.WriteString("func Packages() []Package {\n")
	out.WriteString("\tcopied := make([]Package, len(packages))\n")
	out.WriteString("\tcopy(copied, packages)\n")
	out.WriteString("\treturn copied\n")
	out.WriteString("}\n")

	formatted, err := format.Source(out.Bytes())
	if err != nil {
		return nil, err
	}

	return formatted, nil
}

func exitf(formatText string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, formatText+"\n", args...)
	os.Exit(1)
}
